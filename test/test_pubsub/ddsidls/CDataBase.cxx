// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file CDataBase.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "CDataBase.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#define CDataBase_max_cdr_typesize 3216ULL;
#define CDataBase_max_key_cdr_typesize 0ULL;

CDataBase::CDataBase()
{
    // octet m_eDataType
    m_eDataType = 0;
    // octet m_eDataSourceType
    m_eDataSourceType = 0;
    // unsigned long m_unFrameId
    m_unFrameId = 0;
    // map<octet, unsigned long long> m_mapTimeStamp

    // map<octet, unsigned long> m_mapDelay

    // map<octet, float> m_mapFps


}

CDataBase::~CDataBase()
{






}

CDataBase::CDataBase(
        const CDataBase& x)
{
    m_eDataType = x.m_eDataType;
    m_eDataSourceType = x.m_eDataSourceType;
    m_unFrameId = x.m_unFrameId;
    m_mapTimeStamp = x.m_mapTimeStamp;
    m_mapDelay = x.m_mapDelay;
    m_mapFps = x.m_mapFps;
}

CDataBase::CDataBase(
        CDataBase&& x) noexcept 
{
    m_eDataType = x.m_eDataType;
    m_eDataSourceType = x.m_eDataSourceType;
    m_unFrameId = x.m_unFrameId;
    m_mapTimeStamp = std::move(x.m_mapTimeStamp);
    m_mapDelay = std::move(x.m_mapDelay);
    m_mapFps = std::move(x.m_mapFps);
}

CDataBase& CDataBase::operator =(
        const CDataBase& x)
{

    m_eDataType = x.m_eDataType;
    m_eDataSourceType = x.m_eDataSourceType;
    m_unFrameId = x.m_unFrameId;
    m_mapTimeStamp = x.m_mapTimeStamp;
    m_mapDelay = x.m_mapDelay;
    m_mapFps = x.m_mapFps;

    return *this;
}

CDataBase& CDataBase::operator =(
        CDataBase&& x) noexcept
{

    m_eDataType = x.m_eDataType;
    m_eDataSourceType = x.m_eDataSourceType;
    m_unFrameId = x.m_unFrameId;
    m_mapTimeStamp = std::move(x.m_mapTimeStamp);
    m_mapDelay = std::move(x.m_mapDelay);
    m_mapFps = std::move(x.m_mapFps);

    return *this;
}

bool CDataBase::operator ==(
        const CDataBase& x) const
{

    return (m_eDataType == x.m_eDataType && m_eDataSourceType == x.m_eDataSourceType && m_unFrameId == x.m_unFrameId && m_mapTimeStamp == x.m_mapTimeStamp && m_mapDelay == x.m_mapDelay && m_mapFps == x.m_mapFps);
}

bool CDataBase::operator !=(
        const CDataBase& x) const
{
    return !(*this == x);
}

size_t CDataBase::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return CDataBase_max_cdr_typesize;
}

size_t CDataBase::getCdrSerializedSize(
        const CDataBase& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.mapTimeStamp())
    {
        (void)a;

            current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

            current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.mapDelay())
    {
        (void)a;

            current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    }

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    for(auto a : data.mapFps())
    {
        (void)a;

            current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    }


    return current_alignment - initial_alignment;
}

void CDataBase::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_eDataType;
    scdr << m_eDataSourceType;
    scdr << m_unFrameId;
    scdr << m_mapTimeStamp;
    scdr << m_mapDelay;
    scdr << m_mapFps;

}

void CDataBase::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_eDataType;
    dcdr >> m_eDataSourceType;
    dcdr >> m_unFrameId;
    dcdr >> m_mapTimeStamp;
    dcdr >> m_mapDelay;
    dcdr >> m_mapFps;
}

/*!
 * @brief This function sets a value in member eDataType
 * @param _eDataType New value for member eDataType
 */
void CDataBase::eDataType(
        uint8_t _eDataType)
{
    m_eDataType = _eDataType;
}

/*!
 * @brief This function returns the value of member eDataType
 * @return Value of member eDataType
 */
uint8_t CDataBase::eDataType() const
{
    return m_eDataType;
}

/*!
 * @brief This function returns a reference to member eDataType
 * @return Reference to member eDataType
 */
uint8_t& CDataBase::eDataType()
{
    return m_eDataType;
}

/*!
 * @brief This function sets a value in member eDataSourceType
 * @param _eDataSourceType New value for member eDataSourceType
 */
void CDataBase::eDataSourceType(
        uint8_t _eDataSourceType)
{
    m_eDataSourceType = _eDataSourceType;
}

/*!
 * @brief This function returns the value of member eDataSourceType
 * @return Value of member eDataSourceType
 */
uint8_t CDataBase::eDataSourceType() const
{
    return m_eDataSourceType;
}

/*!
 * @brief This function returns a reference to member eDataSourceType
 * @return Reference to member eDataSourceType
 */
uint8_t& CDataBase::eDataSourceType()
{
    return m_eDataSourceType;
}

/*!
 * @brief This function sets a value in member unFrameId
 * @param _unFrameId New value for member unFrameId
 */
void CDataBase::unFrameId(
        uint32_t _unFrameId)
{
    m_unFrameId = _unFrameId;
}

/*!
 * @brief This function returns the value of member unFrameId
 * @return Value of member unFrameId
 */
uint32_t CDataBase::unFrameId() const
{
    return m_unFrameId;
}

/*!
 * @brief This function returns a reference to member unFrameId
 * @return Reference to member unFrameId
 */
uint32_t& CDataBase::unFrameId()
{
    return m_unFrameId;
}

/*!
 * @brief This function copies the value in member mapTimeStamp
 * @param _mapTimeStamp New value to be copied in member mapTimeStamp
 */
void CDataBase::mapTimeStamp(
        const std::map<uint8_t, uint64_t>& _mapTimeStamp)
{
    m_mapTimeStamp = _mapTimeStamp;
}

/*!
 * @brief This function moves the value in member mapTimeStamp
 * @param _mapTimeStamp New value to be moved in member mapTimeStamp
 */
void CDataBase::mapTimeStamp(
        std::map<uint8_t, uint64_t>&& _mapTimeStamp)
{
    m_mapTimeStamp = std::move(_mapTimeStamp);
}

/*!
 * @brief This function returns a constant reference to member mapTimeStamp
 * @return Constant reference to member mapTimeStamp
 */
const std::map<uint8_t, uint64_t>& CDataBase::mapTimeStamp() const
{
    return m_mapTimeStamp;
}

/*!
 * @brief This function returns a reference to member mapTimeStamp
 * @return Reference to member mapTimeStamp
 */
std::map<uint8_t, uint64_t>& CDataBase::mapTimeStamp()
{
    return m_mapTimeStamp;
}
/*!
 * @brief This function copies the value in member mapDelay
 * @param _mapDelay New value to be copied in member mapDelay
 */
void CDataBase::mapDelay(
        const std::map<uint8_t, uint32_t>& _mapDelay)
{
    m_mapDelay = _mapDelay;
}

/*!
 * @brief This function moves the value in member mapDelay
 * @param _mapDelay New value to be moved in member mapDelay
 */
void CDataBase::mapDelay(
        std::map<uint8_t, uint32_t>&& _mapDelay)
{
    m_mapDelay = std::move(_mapDelay);
}

/*!
 * @brief This function returns a constant reference to member mapDelay
 * @return Constant reference to member mapDelay
 */
const std::map<uint8_t, uint32_t>& CDataBase::mapDelay() const
{
    return m_mapDelay;
}

/*!
 * @brief This function returns a reference to member mapDelay
 * @return Reference to member mapDelay
 */
std::map<uint8_t, uint32_t>& CDataBase::mapDelay()
{
    return m_mapDelay;
}
/*!
 * @brief This function copies the value in member mapFps
 * @param _mapFps New value to be copied in member mapFps
 */
void CDataBase::mapFps(
        const std::map<uint8_t, float>& _mapFps)
{
    m_mapFps = _mapFps;
}

/*!
 * @brief This function moves the value in member mapFps
 * @param _mapFps New value to be moved in member mapFps
 */
void CDataBase::mapFps(
        std::map<uint8_t, float>&& _mapFps)
{
    m_mapFps = std::move(_mapFps);
}

/*!
 * @brief This function returns a constant reference to member mapFps
 * @return Constant reference to member mapFps
 */
const std::map<uint8_t, float>& CDataBase::mapFps() const
{
    return m_mapFps;
}

/*!
 * @brief This function returns a reference to member mapFps
 * @return Reference to member mapFps
 */
std::map<uint8_t, float>& CDataBase::mapFps()
{
    return m_mapFps;
}


size_t CDataBase::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    static_cast<void>(current_alignment);
    return CDataBase_max_key_cdr_typesize;
}

bool CDataBase::isKeyDefined()
{
    return false;
}

void CDataBase::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
}
